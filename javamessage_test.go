package hessian

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"errors"
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
)

type traceVoT struct {
	Key   string
	Value string
}

//HessianCodecName for struct
func (traceVoT) HessianCodecName() string {
	return "hessian.TraceVo"
}

type traceDataT struct {
	Seq  int
	Data traceVoT
}

//HessianCodecName for struct
func (traceDataT) HessianCodecName() string {
	return "hessian.TraceData"
}

// ref java class: github.com/vogo/gohessian/tests/java-tests/src/main/java/hessian/javaMessageT.java
type javaMessageT struct {
	Title string
	Msg   []traceDataT
}

//HessianCodecName for struct
func (javaMessageT) HessianCodecName() string {
	return "hessian.Message"
}

func decodeJavaMessage(t *testing.T, data []byte, typMap map[string]reflect.Type) (msg *javaMessageT, err error) {
	if data == nil || len(data) == 0 {
		return nil, errors.New("nil byte")
	}
	res, err := ToObject(data, typMap)
	if err != nil {
		t.Log("failed decode bytes:", base64.StdEncoding.EncodeToString(data))
		return nil, err
	}
	if sn, ok := res.(*javaMessageT); ok {
		msg = sn
		return
	}
	err = errors.New("failed to decode")
	return
}

func encodeJavaMessage(t *testing.T, msg *javaMessageT, nameMap map[string]string) ([]byte, error) {
	return ToBytes(*msg, nameMap)
}

func buildJavaMessageObject() *javaMessageT {
	return &javaMessageT{
		Title: "t1",
		Msg: []traceDataT{
			{
				Seq:  111,
				Data: traceVoT{"k1", "v1"},
			},
			{
				Seq:  112,
				Data: traceVoT{"k2", "v2"},
			},
			{
				Seq:  113,
				Data: traceVoT{"k3", "v3"},
			},
		},
	}
}

func TestJavaMessageEncode(t *testing.T) {
	msg := buildJavaMessageObject()
	typeMap, nameMap := ExtractTypeNameMap(msg)
	t.Log(typeMap)
	t.Log(nameMap)

	bt, err := encodeJavaMessage(t, msg, nameMap)
	if err != nil {
		t.Error(err)
		t.Fail()
	}

	t.Log("java message go base64: ", base64.StdEncoding.EncodeToString(bt))
	t.Log("java message go string: ", string(bt))
	decodeMsg, err := decodeJavaMessage(t, bt, typeMap)
	if err != nil {
		t.Error(err)
		t.Fail()
	}

	t.Log(decodeMsg)
	assert.Equal(t, msg.Title, decodeMsg.Title)
	assert.Equal(t, len(msg.Msg), len(decodeMsg.Msg))
}

func BenchmarkJavaMessageCodec(b *testing.B) {
	c := buildJavaMessageObject()

	buffer := bytes.NewBuffer(nil)
	reader := bufio.NewReader(buffer)
	serializer := NewSerializer(ExtractTypeNameMap(c))
	err := serializer.WriteTo(buffer, c)
	_, err = serializer.ReadFrom(reader)
	assert.Nil(b, err)
	err = serializer.Write(c)
	assert.Nil(b, err)
	_, err = serializer.Read()
	assert.Nil(b, err)

	for i := 0; i < b.N; i++ {
		serializer.Write(c)
		serializer.Read()
	}
}

func TestJavaMessageDecode(t *testing.T) {
	// NOTE: the following base64 string is generated by github.com/vogo/gohessian/tests/java-tests/src/test/java/hessian/MessageTest.java
	b64 := "Qw9oZXNzaWFuLk1lc3NhZ2WSBXRpdGxlA21zZ2ACbTF6QxFoZXNzaWFuLlRyYWNlRGF0YZIDc2VxBGRhdGFh1eJAQw9oZXNzaWFuLlRyYWNlVm+SA2tleQV2YWx1ZWICazECdjFh1eJBYgJrMgJ2Mg=="
	bytes, err := base64.StdEncoding.DecodeString(b64)
	t.Log(string(b64))
	assert.Nil(t, err)

	javaMessage := javaMessageT{}
	typeMap := TypeMapFrom(javaMessage)

	t.Log(string(bytes))
	msg, err := decodeJavaMessage(t, bytes, typeMap)
	assert.Nil(t, err)

	t.Log(msg)
}
